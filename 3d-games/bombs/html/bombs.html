<!DOCTYPE html>

<html>

<head>
    <title>Example 01.04 - Materials, light and animation</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/FlyControls.js"></script>
    <script type="text/javascript" src="../libs/jquery-1.9.0.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var scene = new THREE.Scene();

        // This is what sees the stuff:
        var aspect_ratio = window.innerWidth / window.innerHeight;
        var camera = new THREE.PerspectiveCamera(75, aspect_ratio, 1, 10000);
        camera.position.z = 500;
        scene.add(camera);

        // This will draw what the camera sees onto the screen:
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        function Bomb(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.bombCount = 0;
            this.isBomb = false;
            this.shape = new THREE.SphereGeometry(50, 20, 15);
            this.cover = new THREE.MeshBasicMaterial();
            this.mesh = new THREE.Mesh(this.shape, this.cover);
            this.mesh.position.set((this.x - 2) * 250, (this.y - 1) * 250, (this.z - 3) * 250);

            this.setColor = function(color) {
                switch(color) {
                    case "red":
                        this.cover.color.setRGB(0.8, 0, 0.1);
                        break;
                    case "orange":
                        this.cover.color.setRGB(0.5, 0.1, 0.2);
                        break;
                    case "yellow":
                        this.cover.color.setRGB(0.3, 0.1, 0.3);
                        break;
                    case "green":
                        this.cover.color.setRGB(0.2, 0.2, 0.5);
                        break;
                    default:
                        this.cover.color.setRGB(0.1, 0.2,0.8);
                }
            };

            this.incrementBombCount = function() {
                this.bombCount++;
                this.setHeat();
            };

            this.heats = ["blue", "green", "yellow", "orange", "red"];

            this.setHeat = function() {
                if(this.isBomb || this.bombCount > 4) {
                    this.setColor("red");
                }
                else {
                    this.setColor(this.heats[this.bombCount]);
                }
            };

            this.toString = function() {
                return "x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", isBomb=" + this.isBomb;
            };

            this.setHeat();
        }

        function Bombs(dimension) {
            this.bombStore = [];
            this.dimension = dimension;

            this.getIndex = function(x, y, z) {
                return x  + y * dimension + z * dimension * dimension;
            };

            this.addBomb = function(bomb) {
                var index = this.getIndex(bomb.x, bomb.y, bomb.z);
                this.bombStore[index] = bomb;
                bomb.setHeat();
            };

            this.getBomb = function(x, y, z) {
                var index = this.getIndex(x, y, z);
                return this.bombStore[index];
            };

            this.placeBomb = function(bx, by, bz) {
                var bomb = this.getBomb(bx, by, bz);
                if(bomb !== undefined) {
                    bomb.isBomb = true;
                    bomb.setHeat();
                    for(var x = bomb.x -1; x <= bomb.x + 1; x++) {
                        for(var y = bomb.y -1; y <= bomb.y + 1; y++) {
                            for(var z = bomb.z -1; z <= bomb.z + 1; z++) {
                                this.incrementBombCountOn(x, y, z);
                            }
                        }
                    }

                }
            };

            this.incrementBombCountOn = function(x, y, z) {
                var bomb = this.getBomb(x, y, z);
                if(bomb !== undefined) { bomb.incrementBombCount(); }
            };
        }

        var bombs = new Bombs(6);
        var d = bombs.dimension;

        for(var x = 0; x < d; x++) {
            for(var y = 0; y < d; y++) {
                for(var z = 0; z < d; z++) {
                    var bomb = new Bomb(x, y, z);
                    bombs.addBomb(bomb);
                    bomb = bombs.getBomb(x, y, z);
                }
            }
        }

        bombs.placeBomb(2, 3, 1);
        bombs.placeBomb(3, 3, 2);
        bombs.placeBomb(2, 2, 1);
        bombs.placeBomb(3, 1, 3);

        for(var i = 0; i < bombs.bombStore.length; i++) {
            bomb = bombs.bombStore[i];
            scene.add(bomb.mesh);
        }

        var flyControls = new THREE.FlyControls(camera);

        flyControls.movementSpeed = 200;
        flyControls.domElement = document.querySelector("#WebGL-output");
        flyControls.rollSpeed = Math.PI / 24;
        flyControls.autoForward = false;
        flyControls.dragToLook = false;

        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        var clock = new THREE.Clock();

        render();

        function render() {
            var delta = clock.getDelta();
            flyControls.update(delta);
            renderer.clear();
            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
    }
    window.onload = init;

</script>
</body>
</html>